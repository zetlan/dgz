<<<<<<< HEAD
<!doctype html>

<!-- Copyright Davis Zetlan,
	October-17-2019,
	June-2-2020   -->
<html>

<head>
	<title>Package Parsing v1.2</title>

	<style>
	body {
		background-color: slateblue;
	}

	#canvas {
		margin: auto;
		border-style: double;
		border-color: slateblue;
		display: block;
		
	}
	</style>


	<script type="text/javascript">
	window.addEventListener("keydown", keyPress, false);
	
	//I store all my global variables at the start of my code so I know where to find them
	var canvas;
	var ctx;
	var timer;
	
	var backgroundColor = "#FFFF88";
	var blobColor = "#008800";
	var blueColor = "#AAAAFF";
	var boxColor = "#8888FF";
	var textColor = "#222266";
	var receiverColor = "#33FF33";
	var select1Color = "#FF8800";
	var select2Color = "#FF8888";
	var font = "Courier";
	var gamePhase = -1;
	var triggered = 0;
	var prob = 1999.9;
	
	var maxConnectors = posit.length;
	var initNumOfConnectors = 3;
	var numOfConnectors = 3;
	var numOfReceivers = 3;
	var hasSelected = 0;
	
	var possibleSelections = ["§","Ω","≈","∞","•", "«", " ", "X", "start - beginner", "start - normal", "start - expert", "Welcome to Package Parsing!", "Ok", "Use the left and right arrow keys to navigate the menu,", "and the up arrow to select options."];
	
	var explanText = [	"Welcome to Package Parsing version 1.2!", 
						"You run a package delivery service,", 
						"and must deliver the packages that the nameless, faceless,", 
						"and limbless package carriers deliver to you.",
						"Use the left and right arrow keys to switch", 
						"which package slot you have selected,", 
						"and press the down arrow key to highlight a package.",
						"Now that you have highlighted a package,",
						"use the arrow keys to select a different package slot",
						"and press z to swap them.",
						"you'll want to swap the package into the position",
						"that goes into its proper box,",
						"which is the one with a matching symbol.",
						"Once you have the package in the correct spot,",
						"Press up to send the selected package to the box.",
						"Congratulations! You have delivered a package!",
						"Every time you deliver a package, the deliverers'",
						"trust, indicated at the lower right corner, increases.",
						"if it drops below zero, you lose.",
						"Have fun delivering more packages! Once you get 15 trust,",
						"the normal game will start.",
						"You're getting close to the normal game.",
						"remember that packages will come quickly",
						"and sometimes unexpectedly. Always be prepared."];
	var posSelectionDestns = [1, 1, 2, 2, 3, 3];
	var selectionsPerBin = 2;
	var selection = [8, 9, 10];
	var selectBuffer = 0;
	var select1 = 1;
	var select2 = 0;
	var timer = 10;
	var countdown = 100;
	var trust = 5;
	var higheTrust = 0;
	var framesRunning = 0;
	var tFramesRunning = [0, 0];
	var menuFrames = 0;
	var howToPlay = 0;
	
	
	var centralWidth = 120;
	var centerX;
	var centerY;
	
	var connectorDist;
	var connectorX;
	var connectorAngle;

	let deliverers = [];
	
	
	window.onload = setup;
	
	//the initializing function.
	function setup() {	
		canvas = document.getElementById("canvas");
		ctx = canvas.getContext("2d");
		centerX = canvas.width / 2;
		centerY = canvas.height / 2;
		window.setInterval(draw, timer);
	}
	
	function keyPress(hn) {
		switch (hn.keyCode) {
			case 27:
				reset();
				break;
				case 37:
				select1 = select1 - 1;
				break;
			case 38:
			parse(select1 - 1);
			select2 = 0;
				break;
			case 39:
				select1 = select1 + 1;
				break;
			case 40:
				select2 = select1;
				break;
		case 90:222
				swap();
			break;
			}
		
		if (select1 > 3) {
			select1 = 1;
		}
		if (select1 < 1) {
			select1 = 3;
		}
	}
	//this function swaps the two selected packages.
	function swap() {
		if (select2 != 0) {
			//this code always makes me slightly concerned that it won't work. It does because that's just how javascript works
			[selection[select1 - 1], selection[select2 - 1]] = [selection[select2 - 1], selection[select1 - 1]];
		}
	}
	
	//this checks to see if the packages are in the right spots and adds score accordingly. This was extremely annoying to put in, because it was hard to keep track of what the code I was writing actually did.
	function parse(binNum) {
		if (gamePhase == 0 || gamePhase == 1) {
			if (Math.floor(selection[binNum] / 2) == binNum) {
			trust = trust + 1;
			selection[binNum] = 6;
			}
		} else {
			switch (selection[binNum]) {
			case 8:
				gamePhase = 0;
			menuFrames = 0;
			selection[0] = 6;
			selection[1] = 6;
			selection[2] = 6;
				break;
			case 9:
				gamePhase = 1;
			menuFrames = 0;
			trust = 15;
			prob = 999.9;
			selection[0] = 6;
			selection[1] = 6;
			selection[2] = 6;
				break;
			case 10:
				gamePhase = 1;
			menuFrames = 0;
			trust = 15;
			prob = 899.9;
			selection[0] = 6;
			selection[1] = 7;
			selection[2] = 6;
				break;
			case 12:
				reset();
				break;
		}
		} 
	}
	
	/*this function is the main function that repeats every time the timer goes off. It clears the screen and then draws everything.  */
	function draw() {
		//the background
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx.fillStyle = backgroundColor;
		ctx.fillRect(0, 40, canvas.width, canvas.height);
		ctx.fillStyle = blueColor;
		ctx.fillRect(0, 0, canvas.width, 40);
		//after the background is drawn, it checks to see whether the game is in a menu state or a game state.
		/*in a game state, the code below activates. This is the stuff that is drawn for both beginner, normal, and expert mode. 
		Currently, expert mode doesn't actually have its own game phase. This is because I can just modify other variables to make the game more difficult.
		Beginner mode has its own game phase because it needs the tutorial. */
		
		switch (gamePhase) {
		case -1:
			//menu state
			ctx.fillStyle = boxColor;
			ctx.fillRect(0, 40, canvas.width, canvas.height);
			drawMenu();
			break;
		case 0:
			//this is the code for the central blob
			ctx.fillStyle = blobColor;
			ctx.beginPath();
			ctx.ellipse(centerX, centerY, centralWidth, 60, Math.PI, 0, Math.PI * 4);
			ctx.fill();
		
			//This part draws the various other interesting things to the screen. Connectors are drawn first so that they are the lowest when compared to other things needed.
			drawConnectors();
			drawSelectionBoxes();
			drawReceivers();
			//this function displays things like trust and time running.
				scoring();
			tutorial();
			break;
		case 1:
			//this is the code for the central blob
			ctx.fillStyle = blobColor;
			ctx.beginPath();
			ctx.ellipse(centerX, centerY, centralWidth, 60, Math.PI, 0, Math.PI * 4);
			ctx.fill();
		
			//This part draws the various other interesting things to the screen. Connectors are drawn first so that they are the lowest when compared to other things needed.
			drawConnectors();
			drawSelectionBoxes();
			drawReceivers();
			//this function displays things like trust and time running.
			scoring();
			framesRunning = framesRunning + 1;
			break;
		case 2:
			break;
		}
		if (gamePhase == 0 || gamePhase == 1) {
			
			//keeping track of time, as well as changing the gamePhase.
		if (gamePhase == 1) {
			
		}
		//this bit changes from the tutorial mode to regular mode and displays the tutorial bits.
			if (gamePhase == 0) {
			
			}
		}
		//if the game is not in a game state, it will either be in an end state or a menu state, so an end state is checked for next.
		else if (gamePhase == 2) {
			scoring();
		} 
		//scoring is outside of that because
	}
	
	function drawConnectors() {
		for (var a=0;a<connectorArray.length;a++) {
		connectorArray[a].beDrawn();
		}
	}
	
	function drawSelectionBoxes() {
		if (gamePhase == 0 || gamePhase == 1) {
			var sizeX = 40;
			var sizeY = 50;
		var offset = 0;
		} else {
			var sizeX = 150;
		var sizeY = 40;
		var offset = 55;
		}
		
		var textSelection = 0;
		//these first for loops draw the different packages. I used Times New Roman instead of Courier because it fit things better.
		ctx.fillStyle = textColor;
		ctx.font = "20px Times New Roman";
				ctx.textAlign = "center";
			for (a = 0; a < selection.length; a++) {
			ctx.fillText(possibleSelections[selection[a]], centerX - (sizeX * 2.5) + ((a+1) * (sizeX + 10)) + offset, centerY);
			}
		
	
		/* this is a little complicated to look at, but the two switch statements are responsible for drawing the two selection boxes in the right spots with the right spacings. Everything else in the function is just getting the styling right and control variables. */
	
			
		ctx.strokeStyle = select1Color;
		ctx.lineWidth = 2;
		ctx.beginPath();
		switch (select1) {
				case 1:
				ctx.rect(centerX - (sizeX * 1.5) - 10, centerY - (sizeY / 2), sizeX, sizeY);
				break;
			case 2:
				ctx.rect(centerX - (sizeX / 2), centerY - (sizeY / 2), sizeX, sizeY);
				break;
			case 3:
				ctx.rect(centerX + (sizeX / 2) + 10, centerY - (sizeY / 2), sizeX, sizeY);
				break;
			}
		ctx.stroke();
		if (select2 != 0) {
			ctx.strokeStyle = select2Color;
		ctx.beginPath();
		switch (select2) {
				case 1:
				ctx.rect(centerX - (sizeX * 1.5) - 7.5, centerY - (sizeY / 2) + 2.5, sizeX - 5, sizeY - 5);
				break;
			case 2:
				ctx.rect(centerX - (sizeX / 2) + 2.5, centerY - (sizeY / 2) + 2.5, sizeX - 5, sizeY - 5);
				break;
			case 3:
				ctx.rect(centerX + (sizeX / 2) + 12.5, centerY - (sizeY / 2) + 2.5, sizeX - 5, sizeY - 5);
				break;
			}
			ctx.stroke();
		}      
	}
	
	function drawReceivers() {
		var b = 0;
		for (a = 1; a <= 3; a++) {
			var goodX = (canvas.width / 3) * a - (canvas.width / 6) - 20;
		var c = 1;
			ctx.fillStyle = receiverColor;
			ctx.fillRect(goodX, 0, 40, 40);
		ctx.fillStyle = textColor;
			ctx.font = "17px Ariel";
					ctx.textAlign = "center";
		while (a == posSelectionDestns[b]) {
			ctx.fillText(possibleSelections[b], goodX + (c * 13) - 2, 15);
			b = b + 1;
			c = c + 1;
		}
		}
	}
	
	function drawMenu() {
	//Title text
		ctx.fillStyle = textColor;
		ctx.font = "20px Courier";
		ctx.textAlign = "center";
		ctx.fillText(possibleSelections[11], centerX, 25);
		
	//draws the menu selection options
			drawSelectionBoxes();
		menuFrames = menuFrames + 1;
		
		
		//if players are stuck on the main menu for more than 15 seconds, inform them of how to control the boxes.
		if (menuFrames > 1500) {
			ctx.font = "15px Courier";
			ctx.fillText(possibleSelections[13], centerX, canvas.height - 25);
		ctx.fillText(possibleSelections[14], centerX, canvas.height - 10);
		}
	}      
	
	function scoring() {
		//drawing the score box
		var countAdjustX = (100 - countdown) * 3.65;
		var countAdjustY = (100 - countdown) * 2.95;
		var trustText = " ";
		ctx.fillStyle = boxColor;
		ctx.fillRect(canvas.width - 150 - countAdjustX, canvas.height - 50 - countAdjustY, canvas.width + 10, canvas.height)
		//this draws the display for the game time and trust.
		ctx.fillStyle = textColor;
		ctx.font = "17px Courier";
				ctx.textAlign = "center";
		
		if (gamePhase == 0 || gamePhase == 1) {
			trustText = "trust: " + trust;
		} 
		else {
			trustText = "Highest trust: " + higheTrust;
		}
		ctx.fillText(trustText, canvas.width - 80 - (countAdjustX / 2), canvas.height - 30 - (countAdjustY / 2));
		
		ctx.fillText("time: " + (framesRunning / 100).toFixed(2), canvas.width - 80 - (countAdjustX / 2), canvas.height - 10 - (countAdjustY / 2));
		
		if (numOfConnectors < maxConnectors && gamePhase == 1) {
			numOfConnectors = numOfConnectors + (0.0005 / (numOfConnectors / 4));
		}
		if (gamePhase == 1 && trust < 0) {
			gamePhase = 2;
		countdown = 99;
		}
		if (gamePhase == 2) {
			if (countdown > 0) {
				countdown = countdown - 1;
		}
		select1 = 2;
		if (countdown == 0) {
			ctx.fillText("Press up to continue", centerX, centerY + 55);
			selection[0] = 6;
			selection[1] = 12;
			selection[2] = 6;
		}
		}
		if (higheTrust < trust) {
			higheTrust = trust;
		}
	}
	
	function tutorial() {
		var a;
		var b;
		//FDP here stands for First Down Press
		var timeSinceFDP = tFramesRunning[0] - tFramesRunning[1];
		console.log(timeSinceFDP);
		//this part is probably very inefficient, but I just hardcoded in when to display the different text boxes.
		//first decides which text boxes to display. A is the number of the text array to start on, and b is how many text boxes to display.
		if (tFramesRunning[0] < 1000) {
			a = 0;
			b = 4;
		triggered = 0;
		}
		else if (tFramesRunning[0] > 1000 && timeSinceFDP > 1000 && triggered != 1) {
			a = 4;
		b = 3;
		if (select2 != 0) {
			tFramesRunning[1] = tFramesRunning[0];
			triggered = 1;
		}
		}
		else if (timeSinceFDP < 1500 && triggered == 1) {
			a = 7;
		b = 6;
		}
		if (timeSinceFDP > 1500 && triggered == 1) {
			a = 13;
		b = 2;
		}
		if (trust == 6) {
			a = 15;
		b = 4;
		}
		if (trust > 6 && trust <= 12) {
			a = 19;
		b = 2;
		}
		if (trust > 12) {
			a = 21;
		b = 3;
		}
	
		//then this for loop displays the text boxes
	
		for (c = 0;c < b; c++) {
			ctx.fillStyle = textColor;
			ctx.font = "14px Courier";
					ctx.textAlign = "center";
			ctx.fillText(explanText[c + a], centerX, centerY - 130 + (c * 13));
		}
		tFramesRunning[0] = tFramesRunning[0] + 1;

		//exiting tutorial
		if (trust >= 15) {
		gamePhase = 1;
		prob = 999.9;
		}
	}
	
	function reset() {
		gamePhase = -1;
		howToPlay = 0;
		trust = 5;
		higheTrust = trust; 
		framesRunning = 0;
		prob = 1999.9;
		countdown = 100;
		numOfConnectors = initNumOfConnectors;
		selection[0] = 8;
		selection[1] = 9;
		selection[2] = 10;
		hasSelected = 0;
		tFramesRunning[0] = 0;
		tFramesRunning[1] = 0;
		
		//resets the package deliverer positions
		for (a = 0; a < posit.length; a++) {
			posit[a] = 50;
		phase[a] = 0;
				}
	}

	//objects go here
	class Deliverer {
		constructor() {
		this.posit = 50;
		this.phase = 0;
		}

		beDrawn() {

			//this part draws the connectors
			connectorDist = canvas.width / numOfConnectors;
			connectorWidth = 120 / numOfConnectors;
			
			for(a = 1; a <= Math.round(numOfConnectors); a++) {
				var decimal = numOfConnectors - Math.floor(numOfConnectors);
				connectorX = connectorDist * a - (connectorDist / 2);
			var h = a - 1;
			
			/*theta here is equal to the arctangent of b over a, where a is the x distance between the center of the connector blob and the center of the main blob, 
			and b is the y distance between the center of the connector blob and the center of the main blob.
			What all this means is that the blobs point towards the main center blob.*/
			connectorAngle = Math.atan(((canvas.height / 2) - canvas.height) / (centerX - connectorX));
			//this next part caclulates the hypotenuse so that the blobs extend to the right length.
			connectorLength = Math.sqrt(Math.pow(Math.abs(canvas.height - centerY), 2) + Math.pow(Math.abs(centerX - connectorX), 2));
			
			/*This is the part that chooses when to send a package. It works by choosing a number between 1 and whatever prob is (1000 in normal mode), and if the number is 5, sending the package.
			
			It is also important that only one maximum blob extends at a time in beginner mode, so th player is not overwhelmed. This is measured with hasSelected.*/
			
			//for normal mode
			if (gamePhase == 1) {
				if (phase[h] == 0) {
					if (Math.floor(Math.random() * prob) == 5) {
						phase[h] = 1;
					}
				}
			}
			//for beginner mode, packages only spawn when there are no packages on the board.
			if (gamePhase == 0) {
				if (phase[h] == 0 && hasSelected == 0) {
					if ((selection[0] + selection[1] + selection[2]) == 18 && Math.floor(Math.random() * prob / 100) == 5) {
						phase[h] = 1;
					hasSelected = 1;
					}
				}
			}
			
			if (phase[h] != 0) {
				//updates position
				posit[h] = posit[h] + phase[h];
				//updates animation phase
				if (posit[h] > connectorLength) {
					receive();
					phase[h] = -1;
				hasSelected = 0;
				} 
				if (posit[h] < 50) {
					phase[h] = 0;
				posit[h] = 50;
				}
			}
			
			//this part below draws the blobs, while the part above sets the parameters for the blobs
				ctx.fillStyle = blobColor;
				ctx.beginPath();
				ctx.ellipse(connectorX, canvas.height, posit[a - 1], connectorWidth, connectorAngle, 0, Math.PI * 4);
				ctx.fill();
			}
		}

		deliver() {
			//attempts to deliver a package
			
			//different in the tutorial vs regular game mode
			if (gamePhase == 0) {

			} else {

			}
		}

	}
	
	</script>
</head>
<body>
	<canvas id="canvas" width="640" height="480">
	</canvas>
</body>
=======
	<!doctype html>

	<!-- Copyright Davis Zetlan,
		October-17-2019          -->
	<html>

	<head>
		<title>Package Parsing v2.0</title>
		<meta charset="utf-8">
		<style>
		body {
			background-color: slateblue;
		}

		#canvas {
			margin: auto;
			border-style: double;
			border-color: slateblue;
			display: block;
			
		}
		</style>


		<script type="text/javascript">
			window.addEventListener("keydown", keyPress, false);
			
			//I store all my global variables at the start of my code so I know where to find them
			var canvas;
			var ctx;
			
			var color_background = "#BDE8FF";
			var color_deliverer = "#008800";
			var color_deliverer_shadow = "#006622";
			var color_stage = "#AAAAFF";
			var color_stage_shadow = "#7777D4";
			var boxColor = "#8888FF";
			var color_text = "#222266";
			var color_collector = "#33FF33";
			var color_collector_shadow = "#12DE78";
			var color_select1 = "#FF8800";
			var color_select2 = "#FF8888";

			var collectors_number = 5;
			var collectors_shadow_offset = 5;
			var collectors_array = [];
			
			var deliverers_array = [];
			var deliverers_shadow_offset = 3;
			var deliverers_initial = 3;
			var deliverers_max = 30;
			var deliverers_frequency = 1000;
			var deliverers_rate = 0.03;
			var deliverers_sending = false;

			var font_large = "40px Courier";
			var font_small = "20px Courier";

			var game_animation;
			var game_animation_speed = 12;
			var game_clock = 0;
			var game_endingDelay = 240;
			var game_deliverer_addTime = 1200;
			var game_deliverer_baseTime = 750;
			var game_deliverer_timeMultiplier = 1.1;
			var game_trust = 5;
			var game_highTrust = game_trust;
			var game_phase = 0;

			var text_menu = ["Welcome to Package Parsing v2.0!",
							"",
							"You are the owner of a package delivery service, ",
							"and must sort and deliver packages.",
							"Use the arrow keys to change the location pointed to,",
							"and use Z to send a package off.",
							"",
							"Press Z to start."];
			
			//since all the packages are represented as a number, this array is used to turn them into visible things drawn on the screen
			var packages_textures = ["§","Ω","≈","∞","•", "«", "ð", "¶", " "];
			var packages_maxID = 7;
			var packages_destinations = [0, 1, 1, 2, 2, 3, 3, 4];
			var packages_key = [["§"], ["Ω", "≈"], ["∞", "•"], ["«", "ð"], ["¶"]];

			var stage_array = [8, 8, 8];
			var stage_arm_selection = 0;
			var stage_arm_selection_animation = 0;
			var stage_angle_difference = Math.PI / 8;
			var stage_arm_length = 120;
			var stage_arm_width = 10;
			var stage_size = 0.15;
			var stage_shadow_offset = 5;
			
			var centralWidth = 120;
			var centerX;
			var centerY;
			
			
			window.onload = setup;
			
			//the initializing function.
			function setup() {
				canvas = document.getElementById("canvas");
				ctx = canvas.getContext("2d");
				ctx.lineJoin = "round";

				centerX = canvas.width / 2;
				centerY = canvas.height / 2;
				game_animation = window.requestAnimationFrame(main);
			
				
			}
			
			function keyPress(hn) {
				switch (hn.keyCode) {
					case 27:
						reset();
						break;
					case 37:
						stage_arm_selection -= 2;
					case 39:
						stage_arm_selection += 1;

						//keeping stage arm in bounds
						if (stage_arm_selection < 0 || stage_arm_selection > collectors_number - 1) {
							if (stage_arm_selection < 0) {
								stage_arm_selection = collectors_number - 1;
							} else {
								stage_arm_selection = 0;
							}
						}
						break;
					case 90:
						game_phase += 1;
						if (game_phase > 0 && game_trust > 0) {
							validatePackage();
						}
						break;
				}
			}
			
			function receive() {
			}
			
			/*this function is the main function that repeats every time the timer goes off. It clears the screen and then draws everything.  */
			function main() {
				//the background
				var gradient = ctx.createRadialGradient(centerX, centerY, 30, centerX, centerY, canvas.height * 0.85);
				gradient.addColorStop(0, color_background);
				gradient.addColorStop(1, "slateblue");

				// Set the fill style and draw a rectangle
				ctx.fillStyle = gradient;
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				switch (game_phase) {
					case -1:
						drawGameOver();
						break;
					case 0:
						drawMenu();
						break;
					case 1:
					default:
						runGame();
						break;
				}
				game_animation = window.requestAnimationFrame(main);
			}


			//drawing functions!


			function dEllipse(color, x, y, xRadius, yRadius, rotation, startAngle, endAngle) {
				ctx.fillStyle = color;
				ctx.beginPath();
				ctx.ellipse(x, y, xRadius, yRadius, rotation, startAngle, endAngle)
				ctx.fill();
			}


			function drawCenterModule() {
				//body shadow
				dEllipse(color_stage_shadow, centerX, centerY + stage_shadow_offset, canvas.width * stage_size, canvas.height * stage_size, 0, 0, Math.PI * 2);

				//arm calculations
				//bringing animated arm closer to selected spot
				stage_arm_selection_animation = ((stage_arm_selection_animation * ((game_animation_speed / 3) - 1)) + stage_arm_selection) / (game_animation_speed / 3);
				//calculating where to draw the arm at
				var armPosX = stage_arm_length * Math.sin((Math.ceil(collectors_number / -2) * stage_angle_difference) + (stage_angle_difference * stage_arm_selection_animation));
				var armPosY = stage_arm_length * 0.75 * Math.cos((Math.ceil(collectors_number / -2) * stage_angle_difference) + (stage_angle_difference * stage_arm_selection_animation));

				//arm
				ctx.lineWidth = stage_arm_width;
				ctx.strokeStyle = color_stage_shadow;
				ctx.beginPath();
				ctx.moveTo(centerX - 3, centerY + stage_shadow_offset);
				ctx.lineTo(centerX + armPosX, centerY + stage_shadow_offset - armPosY);
				ctx.lineTo(centerX + 3, centerY + stage_shadow_offset);
				ctx.stroke();

				//arm 2
				ctx.lineWidth = stage_arm_width;
				ctx.strokeStyle = color_stage;
				ctx.beginPath();
				ctx.moveTo(centerX - 3, centerY);
				ctx.lineTo(centerX + armPosX, centerY - armPosY);
				ctx.lineTo(centerX + 3, centerY);
				ctx.stroke();

				//body
				dEllipse(color_stage, centerX, centerY, canvas.width * stage_size, canvas.height * stage_size, 0, 0, Math.PI * 2);

				//packages
				ctx.fillStyle = color_text;
				ctx.font = font_large;
				for (var c=0;c<stage_array.length;c++) {
					ctx.fillText(packages_textures[stage_array[c]], centerX, centerY + 10 + (40 * (c - 1)));
				}
			}

			function drawGameOver() {
				ctx.fillStyle = color_text;
				ctx.font = font_small;
				ctx.fillText("The Package Manufacturers no longer trust you.", centerX, canvas.height * 0.3);
				ctx.fillText("Your business was good while it lasted, though.", centerX, canvas.height * 0.35);
				ctx.fillText(`Highest Total Trust: ${game_highTrust}`, centerX, canvas.height * 0.45);
				ctx.fillText(`Time lasted: ${(game_clock / 60).toFixed(2)} seconds`, centerX, canvas.height * 0.5);
			}

			function drawMenu() {
				ctx.fillStyle = color_text;
				ctx.font = font_small;
				for (var i=0;i<text_menu.length;i++) {
					ctx.fillText(text_menu[i], centerX, canvas.height * (0.2 + (i * 0.05)));
				}

				startGame();
			}

			function drawScoreText() {
				ctx.font = font_small;
				ctx.fillStyle = color_text;
				ctx.fillText(`Trust: ${game_trust}`, canvas.width * 0.25, canvas.height * 0.98);
				ctx.fillText(`Time: ${(game_clock / 60).toFixed(2)}`, canvas.width * 0.75, canvas.height * 0.98);
			}

			function endGame() {
				//pre-end of game stuff
				for (var a=0;a<deliverers_array.length;a++) {
					deliverers_array[a].number = deliverers_array.length + 1;
				}

				for (var b=0;b<collectors_array.length;b++) {
					collectors_array[b].number = collectors_array.length + 1;
				}
			}

			function startGame() {
				//first reset things
				stage_array = [8, 8, 8];
				deliverers_array = [];
				collectors_array = [];

				game_clock = 0;
				game_deliverer_addTime = 1200;
				game_deliverer_baseTime = 750;
				deliverers_sending = false;
				game_trust = 5;
				game_highTrust = 0;
				game_endingDelay = 240;

				//text stuffies
				ctx.font = font_large;
				ctx.textAlign = "center";

				//populating deliverer array
				while (deliverers_array.length < deliverers_initial) {
					deliverers_array.push(new Deliverer(deliverers_array.length));
				}

				//populating reciever array
				for (var e=0;e<collectors_number;e++) {
					collectors_array.push(new Collector(e));
				}
			}

			function runGame() {
				//drawing center module
				drawCenterModule();


				//deliverers
				for (var a=0;a<deliverers_array.length;a++) {
					deliverers_array[a].beDrawn();
					deliverers_array[a].tick();
				}

				//recievers
				for (var b=0;b<collectors_array.length;b++) {
					collectors_array[b].beDrawn();
					collectors_array[b].tick();
				}

				drawScoreText();



				//incrementing game stuffies
				if (game_trust > 0) {
					game_clock += 1;
					if (game_clock > game_deliverer_addTime) {
						//working out next time to add deliverer
						game_deliverer_addTime += game_deliverer_baseTime;
						game_deliverer_baseTime *= game_deliverer_timeMultiplier;

						//adding another deliverer if there aren't already too many
						if (deliverers_array.length < deliverers_max) {
							deliverers_array.push(new Deliverer(deliverers_array.length));
						}
					}

					if (game_trust > game_highTrust) {
						game_highTrust = game_trust;
					}
				} else {
					game_trust = 0;
					game_endingDelay -= 1;
					if (game_endingDelay == 0) {
						game_phase = -1;
					}
				}
				
			}

			function validatePackage() {
				//if the package in slot zero is going to its correct location, remove it and update the rest
				if (stage_arm_selection == packages_destinations[stage_array[0]]) {
					for (var d=0;d<stage_array.length-1;d++) {
						stage_array[d] = stage_array[d + 1];
					}
					stage_array[stage_array.length-1] = packages_maxID + 1;
				}
			}







			//classes!

			class SharedFunctionality {
				constructor(number) {
					this.adjustDelay = game_animation_speed;
					this.size = 15;
					this.number = number;
					this.x = canvas.width;

					this.targetX = 0;
					this.y = 0;
					this.shadowY = 0;
					this.color = "#FFFFFF";
					this.shadowColor = "#FFFFFF";
				}

				beDrawn() {
					dEllipse(this.shadowColor, this.x, this.shadowY, this.size, this.size * 0.75, 0, 0, Math.PI * 2);
					dEllipse(this.color, this.x, this.y, this.size, this.size * 0.75, 0, 0, Math.PI * 2);
				}

				tick() {
					//move according to x / target x
					this.x = ((this.x * (this.adjustDelay - 1)) + this.targetX) / this.adjustDelay;
				}
			}



			class Deliverer extends SharedFunctionality {
				constructor(number) {
					super(number);

					this.targetX = (canvas.width / (deliverers_array.length + 1)) * (this.number + 1);
					this.y = canvas.height * 0.9;
					this.shadowY = this.y + deliverers_shadow_offset;

					this.color = color_deliverer;
					this.shadowColor = color_deliverer_shadow;

					this.progress = 0;
					this.deliveryNumber = 8;
				}

				beDrawn() {
					super.beDrawn();

					//draw current delivery package over self, simple linterp towards the center
					var modProg = this.progress * this.progress * this.progress;
					var drawX = this.x + (modProg * (centerX - this.x));
					var drawY = this.y + 5 + (modProg * (centerY - this.y));
					ctx.font = font_small;
					ctx.fillStyle = color_text;
					ctx.fillText(packages_textures[this.deliveryNumber], drawX, drawY);
				}

				tick() {
					//decide whether to send a package
					/*the condition for sending a package is a 1/frequency random chance.
					The chance is also increased if the stage is empty, and is 0 if trust is below 0 */
					var activeFrequency = Infinity;
					if (game_trust > 0) {
						activeFrequency = deliverers_frequency / (1 + 2 * (stage_array[0] == 8));
					}
					var sendPackage = Math.floor(Math.random() * activeFrequency) == 5;
					//if decided to possibly send a package, additional checks are added for making sure self is not already sending a package
					if (sendPackage && this.progress == 0) {
						this.deliveryNumber = Math.floor(Math.random() * (packages_maxID + 0.99));
					}

					//advancing the package forwards
					if ((this.deliveryNumber != 8 && !deliverers_sending && game_trust > 0) || this.progress > 0) {
						deliverers_sending = true;
						this.progress += deliverers_rate;
						if (this.progress >= 1) {
							
							for (var g=0;g<stage_array.length;g++) {
								//completing the delivery
								if (stage_array[g] == 8) {
									stage_array[g] = this.deliveryNumber;
									this.deliveryNumber = 8;
									game_trust += 1;
									g = stage_array.length + 1;
								}
							}

							//failing the delivery
							if (this.deliveryNumber != 8) {
								game_trust -= 5;
								this.deliveryNumber = 8;
								if (game_trust <= 0) {
									endGame();
								}
							}

							//things that happen regardless of delivery outcome
							this.progress = 0;
							deliverers_sending = false;
						}
					}

					//moving
					this.targetX = (canvas.width / (deliverers_array.length + 1)) * (this.number + 1);
					super.tick();
					
				}
			}

			class Collector extends SharedFunctionality {
				constructor(number) {
					super(number);

					this.size = 25;
					this.y = canvas.height * 0.1;
					this.shadowY = this.y + collectors_shadow_offset;

					this.color = color_collector;
					this.shadowColor = color_collector_shadow;
				}

				beDrawn() {
					super.beDrawn();
					//drawing what to recieve
					var target = packages_key[this.number];
					if (target == undefined) {
						target = packages_textures[8];
					}
						
					ctx.font = font_small;
					ctx.fillStyle = color_text;
					for (var f=0;f<target.length;f++) {
						ctx.fillText(target[f], this.x, this.y + 10 + (15 * (f - 1)));
					}
				}

				tick() {
					this.targetX = (canvas.width / (collectors_array.length + 1)) * (this.number + 1);
					super.tick();
				}
			}







		</script>
	</head>
	<body>
		<canvas id="canvas" width="640" height="480">
		</canvas>
	</body>
>>>>>>> development
</html>
