<!doctype html>
<!-- Copyright Davis Zetlan
Nov-17-2019 -->
<html>
	<head>
    	<title>The Ascent Again v0.4</title>

    	<style>
      		#canvas {
        		border-style: double;
        		border-color: slateblue;
        		margin: auto;
        		display: block;
      		}
		</style>
		<script src="helper.js"></script>
    	<script type="text/javascript">
      		window.addEventListener("keydown", keyPress, false);
      		window.addEventListener("keyup", keyNegate, false);
      		//setting up variables for later
      		var canvas;
      		var ctx;
			var dx = 0;
			var dy = 0;
			
			var hasPressed = 0;
			
			var arrayValue;
			var centerX;
			var centerY;
			var squareSize = 40;
			var startingCoords = [240, 101];
			var mouseX;
			var mouseY;
			var clicked = 0;
			var numToSet = 0;
			var canvasArea;
			var gravity = squareSize / 100;
			
			var timer;
			var dayLength = 12500;
			var time = 0;
			var points = 0;
			
			var gameState = -1;
			var yes = 0;
			var delay = 10;
			
			//all the colors used

			//blocks
			var landColor = "#773C08";
			var lLandColor = "#9B5618";
			var grassColor = "#008800";
			var stoneColor = "#494D5E";
			var lStoneColor = "#797D8E";
			var woodColor = "#AB6E05";
			var lWoodColor = "#DB8F0B";
			var skyColor = "#AAAAFF";
			var skySecondaryColor = "#FFFFFF";
			var floorColor = "#D1AC6D";
			var farmColor = "#916B2F";
			var endingColor = "#FF00FF";
			var startingColor = "#00FF00";
			var blackColor = "#000000";

			//entities
			var ballColor = "#FF00FF";
			var buttonColor = "#FF4444";
			var pressedButtonColor = "#44FF44";
			
			var menuColor = "#333366";
			var textColor = "#EEEEEE";
			var entityColor = "#8800FF";
			var nightFilter = "#000044";
			
			var prep = [0, 0, 0, 0];

			var menuText = ["The Ascent", "Start", "(Click to start)"];
			
			var loadingMap;		
			
			/*this array determines the positions of all the entities as well as their profession.
			It's format is [x, y, point value, color, exists or not]*/
			var entityData = [[54.5 * squareSize, 105 * squareSize, 10, "#8A8A2F", 1],
								[6.5 * squareSize, 12.5 * squareSize, 100, "#FFEA4F", 1],
								[24.5 * squareSize, 92.5 * squareSize, "To move, use the arrow keys or WASD.", "#000000", 2],
								[27.5 * squareSize, 82.5 * squareSize, "You regain your jump when hitting the lower side of blocks.", "#000000", 2],
								[55.5 * squareSize, 7.5 * squareSize, "Hey â˜ƒ", "#000000", 2]
								];
			var entitySpeed = 1;

			//this array says all the surfaces that are solid and cannot be walked through.
			var solidSurfaces = [1, 2, 4, 6];

			window.onload = setup;
			document.onmousemove = mouseHandle;
			document.onmousedown = clickHandle;

			let camera;
			let character;

			let entities = [new Button(1480, 3240, new Gelatin(1440, 3200), 0, 0, false, [[37, 74, 1, 0], [38, 74, 1, 0]])];
			// the initializing function.
			function setup() {
				canvas = document.getElementById("canvas");
				ctx = canvas.getContext("2d");
				loadingMap = map;
				setInterval(draw, 15);
				
				centerX = canvas.width / 2;
				centerY = canvas.height / 2;

				camera = new Camera(0, 0);
				character = new Player(startingCoords[0], startingCoords[1]);
			}
			
			function keyPress(h) {
				//37, 38, 39, and 40 are the arrow keys. Left, up, and right can only be activated if delay is 0, meaning not during cutscenes. Down can still be used.
				//there is one switch statement that controls all the key presses
				//dx is controlled by ax, but dy is updated directly for a more snappy feeling
				switch (h.keyCode) {
					case 65:
					case 37:
						character.ax = character.accRate * -1;
						break;
					case 87:
					case 38:
						if (character.onGround) {
							character.dy = character.jumpStrength * -1;
							character.onGround = false;
						}
						break;
					case 68:
					case 39:
						character.ax = character.accRate * 1;
						break;
					case 83:
					case 40:
						character.dy += character.jumpStrength;
						break;
					
					//z, x, and c, in that order
					case 90:
						hasPressed = 1;
						break;
					case 88:
						character.tryReset();
						break;
					case 67:
						camera.modifyPosition();
						break;
				}
			}
			
			function keyNegate(h) {
				switch (h.keyCode) {
					case 65:
					case 37:
						character.ax = 0;
						break;
					case 87:
					case 38:
						character.ay = 0;
						break;
					case 68:
					case 39:
						character.ax = 0;
						break;
					case 83:
					case 40:
						character.ay = 0;
						break;
				}
			}

			function draw() {
				//drawing everything

				//sky
				ctx.fillStyle = skyColor;
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.fillStyle = skySecondaryColor;
				ctx.globalAlpha = 0.2;
				//secondary band scales with height
				// [maxY - playerY] / [maxY] to get the band to go down as Y increases
				var thatPercent = ((loadingMap.length * squareSize) - character.y) / (loadingMap.length * squareSize);
				ctx.fillRect(0, 0, canvas.width, canvas.height * thatPercent);
				ctx.globalAlpha = 1;

				drawMap();
				character.beDrawn();

				
				//ticking everything
				for (var g=0;g<entities.length;g++) {
					entities[g].tick();
					entities[g].beDrawn();
				}
				//camera is drawn last so it's on top of everything
				camera.beDrawn();
				
				character.tick();
				camera.tick();
			}
			
			function mouseHandle(h) {
				canvasArea = canvas.getBoundingClientRect();
				mouseX = Math.round(h.clientX - canvasArea.left);
				mouseY = Math.round(h.clientY - canvasArea.top);
			}
			
			function clickHandle() {
				if (prep[0] >= 5 || gameState < 0) {
					clicked = 1;
				}
			}

			/* mapSquare is the function that draws all the different tiles. */
			function mapSquare(value, ex, why, offset) {
					switch (value) {
					case 0:
						ctx.fillStyle = landColor;
						ctx.fillRect(ex, why, squareSize - offset, squareSize - offset);
						break;
					case 1:
						ctx.fillStyle = landColor;
						ctx.fillRect(ex, why, squareSize - offset, squareSize - offset);
						ctx.fillStyle = lLandColor;
						ctx.fillRect(ex + (squareSize / 8), why + (squareSize / 8), (squareSize * 0.75) - offset, (squareSize * 0.75) - offset);
						break;
					case 2:
						ctx.fillStyle = landColor;
						ctx.fillRect(ex, why, squareSize - offset, squareSize - offset);
						ctx.fillStyle = lLandColor;
						ctx.fillRect(ex + (squareSize / 8), why + (squareSize / 8), (squareSize * 0.75) - offset, (squareSize * 0.75) - offset);
						ctx.fillStyle = grassColor;
						ctx.fillRect(ex + (squareSize / 8), why, (squareSize * 0.75) - offset, squareSize / 4);
						break;
					case 3:
						ctx.fillStyle = stoneColor;
						ctx.fillRect(ex, why, squareSize - offset, squareSize - offset);
						break;
					case 4:
						ctx.fillStyle = stoneColor;
						ctx.fillRect(ex, why, squareSize - offset, squareSize - offset);
						ctx.fillStyle = lStoneColor;
						ctx.fillRect(ex + (squareSize / 8), why + (squareSize / 8), (squareSize * 0.75) - offset, (squareSize * 0.75) - offset);
						break;
					case 5:
					ctx.fillStyle = woodColor;
						ctx.fillRect(ex, why, squareSize - offset, squareSize - offset);
					break;
					case 6:
						ctx.fillStyle = woodColor;
						ctx.fillRect(ex, why, squareSize - offset, squareSize - offset);
						ctx.fillStyle = lWoodColor;
						ctx.fillRect(ex + (squareSize / 8), why + (squareSize / 8), (squareSize * 0.75) - offset, (squareSize * 0.75) - offset);
					break;
					case 9:
					default:
						break;
				}
			}
					
			// drawing the map
			function drawMap() {
				//uses two for loops, one for x and one for y
				for (var p=0; p<camera.ySquaresPerScreen; p++) {
					for (var o=0;o<camera.xSquaresPerScreen;o++) {
						//figuring out where to read from
						var value;
						var xSquare = Math.floor((camera.cornerX + (o * squareSize)) / squareSize);
						var ySquare = Math.floor((camera.cornerY + (p * squareSize)) / squareSize);

						//wrapping horizontally
						if (xSquare >= loadingMap[0].length) {
							xSquare -= loadingMap[0].length;
						} else if (xSquare < 0) {
							xSquare += loadingMap[0].length;
						}

						//where to write to
						//[square numbers] - [square offset]
						var xPos = (o * squareSize) - (camera.cornerX % squareSize);
						var yPos = (p * squareSize) - (camera.cornerY % squareSize);

						//modulo returns a negative number when x is negative, so I have to correct it
						if (camera.cornerX < 0) {
							xPos -= squareSize;
						}

						try {
							value = loadingMap[ySquare][xSquare];
						}
						catch (error) {
							value = 9;
						}
						//the actual drawing, xPos and yPos are floored so that subpixels don't create ugly lines
						mapSquare(value, Math.floor(xPos), Math.floor(yPos), 0);
					}
				}
			}
			
			function drawMenu() {
				//filters count as part of the menu
				ctx.textAlign = "left";
				//prep filter, it's probably not the best to handle the prepping logic inside of a draw function but whatever
				if (prep[0] > 0 && prep[0] < 5) {
					ctx.globalAlpha = 0.2;
					ctx.fillStyle = endingColor;
					ctx.fillRect(0, 0, canvas.width * (prep[0] / 4.5), canvas.height);
					ctx.globalAlpha = 1.0;
					prep[1] = prep[1] - 1;
					if (prep[1] < 1) {
						prep[0] = prep[0] - 0.05;
					}
				}
				//prep for return filter
				if (prep[2] > 0 && prep[2] < 5) {
					ctx.globalAlpha = 0.2;
					ctx.fillStyle = startingColor;
					ctx.fillRect(0, 0, canvas.width * (prep[2] / 4.5), canvas.height);
					ctx.globalAlpha = 1.0;
					prep[3] = prep[3] - 1;
					if (prep[3] < 1) {
						prep[2] = prep[2] - 0.05;
					}
				}
				
					
				//draws main menu things
				ctx.fillStyle = menuColor;
				ctx.fillRect(0, canvas.height * 0.8, canvas.width, canvas.height * 0.2)
				ctx.fillStyle = textColor;
				ctx.font = "20px Century Gothic";
				ctx.fillText("Time elapsed: " + (time / 66.6666666).toFixed(2), 15, canvas.height * 0.95); 
				ctx.fillText("Points: " + points, 15, canvas.height * 0.87);
			}

			function mapEdit() {
				//converts the mouses position into a spot on the map, allows for click edits.
				var max = 9;
				var arrayPosX = mouseX + cornerCoords[0];
				var arrayPosY = mouseY + cornerCoords[1];
				time = Math.round(dayLength * 0.80);
				
				if (clicked == 1) {
					clicked = 0;
				loadingMap[Math.floor(arrayPosY / squareSize)][Math.floor(arrayPosX / squareSize)] = numToSet;
				if (loadingMap[Math.floor(arrayPosY / squareSize)][Math.floor(arrayPosX / squareSize)] > max) {
					loadingMap[Math.floor(arrayPosY / squareSize)][Math.floor(arrayPosX / squareSize)] = 0;
				}
				}

				//makes sure that text displays the coordinates
				textValue[0] = 9;
				textTime = 100;
			}
			
			function mapOutput() {
				var hey = "";
				for (s=0;s<loadingMap.length;s++) {
					hey = hey + "\n [";
					for (t=0;t<loadingMap[s].length;t++) {
					//special case for the end of a line, in addition to a regular case
					if (t == (loadingMap[s].length - 1)) {
					hey = hey + loadingMap[s][t];
					} else {
					hey = hey + loadingMap[s][t] + ", ";
					}
				}
				//the same thing happens here with the end of the map
				if (s == (map.length - 1)) {
					hey = hey + "]";
				} else {
					hey = hey + "],";
				}
				}
				console.log(hey);
			}
    	</script>
  	</head>
  	<body>
    	<div>
      		<canvas id="canvas" width="640" height="480">
      		</canvas>
    	</div>
	</body>
</html>