<!DOCTYPE html>
<html>
  	<head>
    	<meta charset="utf-8">
    	<meta name="viewport" content="width=device-width">
    	<title>Lovely Linies</title>
		<style>

		body {
			background-color: slateblue;
		}
		#canvas {
			border-style: double;
			border-color: slateblue;
			margin: auto;
			display: block;
		}
		</style>
  	</head>
	<body>
		<script type="text/javascript">
            var loadingMaze = [];
            var arrSize = 20;
            var squareSize = 20;
			var changeSpeed = 0;
            var maxChangeSpeed = 0.0055;
            
            var timer;

            var color_bg = "#008800";
            var color_wall = "#000000";

			window.onload = setup;
			function setup() {      
				canvas = document.getElementById("canvas");
                ctx = canvas.getContext("2d");

                document.getElementById("cellRange").oninput = updateCellNum;

                squareSize;
                [canvas.width, canvas.height] = [squareSize * arrSize, squareSize * arrSize];

				centerX = canvas.width / 2;
                centerY = canvas.height / 2;

                //setting up maze
                resetMaze();
                
                timer = window.requestAnimationFrame(draw);
			}

			function draw() {
                if (loadingMaze[0][0][2] == false) {
                    generateMaze();
                }
                
                ctx.fillStyle = color_bg;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                //drawing the cells
                drawMaze();

                //drawing the player
                drawPlayer();
                timer = window.requestAnimationFrame(draw);
            }
            
            function drawMaze() {
                for (var c=0;c<loadingMaze.length;c++) {
                    for (var d=0;d<loadingMaze[c].length;d++) {

                        ctx.fillStyle = "#FFFFFF";
                        if (loadingMaze[c][d][2]) {
                            ctx.fillRect(d * squareSize, c * squareSize, squareSize, squareSize);
                        }

                        //drawing walls
                        ctx.fillStyle = color_wall;
                        if (loadingMaze[c][d][1]) {
                            ctx.fillRect(d * squareSize, c * squareSize, squareSize, 1);
                        }

                        if (loadingMaze[c][d][0]) {
                            ctx.fillRect(d * squareSize, c * squareSize, 1, squareSize);
                        }                        
                    }
                }
            }

            function drawPlayer() {

            }

            function generateMaze() {
                var posStack = [[0, 0]];
                var numOfSquares = arrSize * arrSize;
                var visitedSquares = 1;

                //go until all squares are done
                while (visitedSquares <= numOfSquares) {
                    //get self data
                    var selfPos = posStack[posStack.length - 1];
                    //get unvisited neighbors in a list
                    var unvisitedNeighbors = [];
                    try {
                        if (loadingMaze[selfPos[0]][selfPos[1]-1][2] === false) {
                            unvisitedNeighbors.push([[selfPos[0], selfPos[1]-1], 0]);
                        }
                    } catch(e) {}
                    try {
                        if (loadingMaze[selfPos[0]-1][selfPos[1]][2] === false) {
                            unvisitedNeighbors.push([[selfPos[0]-1, selfPos[1]], 1]);
                        }
                    } catch(e) {}
                    try {
                        if (loadingMaze[selfPos[0]][selfPos[1]+1][2] === false) {
                            unvisitedNeighbors.push([[selfPos[0], selfPos[1]+1], 2]);
                        }
                    } catch(e) {}
                    try {
                        if (loadingMaze[selfPos[0]+1][selfPos[1]][2] === false) {
                            unvisitedNeighbors.push([[selfPos[0]+1, selfPos[1]], 3]);
                        }
                    } catch(e) {}
                        

                    //if the list is empty, pop one off the stack and try again
                    if (unvisitedNeighbors.length == 0) {
                        posStack.pop();
                    } else {
                        //if not, choose one at random
                        var chosenIndex = Math.floor(Math.random() * unvisitedNeighbors.length);
                        var chosen = unvisitedNeighbors[chosenIndex];
                        console.log(chosenIndex, unvisitedNeighbors);

                        //break the walls between them
                        switch (chosen[1]) {
                            case 0:
                                loadingMaze[selfPos[0]][selfPos[1]][0] = false;
                                break;
                            case 1:
                                loadingMaze[selfPos[0]][selfPos[1]][1] = false;
                                break;
                            case 2:
                                loadingMaze[selfPos[0]][selfPos[1]+1][0] = false;
                                break;
                            case 3:
                                loadingMaze[selfPos[0]+1][selfPos[1]][1] = false;
                                break;
                        }

                        //add it to the stack
                        posStack.push(chosen[0]);
                    }

                    //cause self to be visited if not already
                    if (!loadingMaze[selfPos[0]][selfPos[1]][2]) {
                        visitedSquares += 1;
                        loadingMaze[selfPos[0]][selfPos[1]][2] = true;
                    }
                }
            }

            function resetMaze() {
                loadingMaze = [];
                for (var a=0;a<arrSize;a++) {
                    loadingMaze.push([]);
                    for (var b=0;b<arrSize;b++) {
                        //each cell has two walls, because the other two can be borrowed from their neighbor
                        loadingMaze[a].push([true, true, false]);
                    }
                }
            }

            function updateCellNum() {
                snakeThick = this.value;
                //updating existing snakes
                for (var d=0;d<snakes.length;d++) {
                    snakes[d].r = snakeThick;
                }
            }
        </script>
        <div id="centeredThings">
    	    <canvas id="canvas" width="400" height="400"></canvas>
            <input type="range" min="2" max="30" value="10" class="slider" id="cellRange">
        </div>
    	
	</body>
</html>
