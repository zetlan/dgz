<html>
    <head>
        <style>
            body {
                background-color: slateblue;
            }

            #cavo {
                margin: auto;
                text-align: center;
                display: block;
            }
            #centerModule {
                text-align: center;
                margin: auto;
                display: block;
            }

        </style>
        <script>
            window.onload = setup;
            document.onmousedown = handlePress;

            //global variables
            var scale = 100;
            var scaleFactor = 1.5;
            var pixelSize = 1;

            var xCenter = 0;
            var yCenter = 0;
            var cornerCoords = [];
            var maxIterations = 255;

            var canvas;
            var ctx;

            //setup function
            function setup() {
                canvas = document.getElementById("cavo");
                ctx = canvas.getContext("2d");
                document.getElementById("zoomRange").oninput = updateScaleFactor;
                document.getElementById("resolutionRange").oninput = updateResolution;

                cornerCoords = [xCenter - (canvas.width / scale) / 2, yCenter - (canvas.height / scale) / 2, xCenter + (canvas.width / scale) / 2, yCenter + (canvas.height / scale) / 2];
                draw();
            }

            //drawing function
            function draw() {
                //two nested for loops to get a two-dimensional draw
                for (var x=0;x<canvas.width/pixelSize;x++) {
                    for (var y=0;y<canvas.height/pixelSize;y++) {
                        /*initializing variables. i is number of iterations, 
                        cx/cy are starting coordinates (stay the same), 
                        and zx/zy are iterating coordiantes (change with every iteration) */
                        var i = 0;
                        var cx = ((x * pixelSize) / scale) + cornerCoords[0];
                        var cy = ((y * pixelSize) / scale) + cornerCoords[1];
                        zx = 0;
                        zy = 0;
                        //main processing loop
                        while(i<maxIterations && (zx*zx+zy*zy)<4) {
                            i += 1;
                            //these are kind of cheaty, I can get away with not using complex numbers with this formula
                            //xt = z
                            xt = zx * zy;
                            //z = z^2 + c
                            zx = zx * zx - zy * zy + cx;
                            zy = 2 * xt + cy;
                        }
                        //drawing colors based on i (iterations before escape)

                        var color;
                        if (i != maxIterations) {
                            color = "hsl(" + (i*4) + ", 75%, 50%)";
                        } else {
                            color = "hsl(0, 0%, 0%)";
                        }
                        ctx.beginPath();
                        ctx.fillStyle = color;
                        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                    }
                }
                //update position text at the end
                var text = "(" + xCenter;
                text += ", " + yCenter;
                text += ", " + (scale / 100).toFixed(3) + ")";
                document.getElementById("totalPos").innerHTML = text;
            }

            function handlePress(v) {
                canvasArea = canvas.getBoundingClientRect();
                //getting pixel x and y of mouse
      	        var mousePosX = Math.round(v.clientX - canvasArea.left);
                var mousePosY = Math.round(v.clientY - canvasArea.top);

                //only continue if the coords are inside the canvas
                var isInside = (mousePosX > 0 && mousePosX < canvas.width) && (mousePosY > 0 && mousePosY < canvas.height);

                if (isInside) {
                    //converting pixel coords to fractal coords
                    mousePosX = (mousePosX / scale) + cornerCoords[0];
                    mousePosY = (mousePosY / scale) + cornerCoords[1];
                    //setting center coords to that
                    xCenter = mousePosX;
                    yCenter = mousePosY;
                    //adjusting scale
                    scale *= scaleFactor;
                    cornerCoords = [xCenter - (canvas.width / scale) / 2, yCenter - (canvas.height / scale) / 2, xCenter + (canvas.width / scale) / 2, yCenter + (canvas.height / scale) / 2];
                    //redrawing
                    draw();
                }
            }

            function updateScaleFactor(bb) {
                //updating value
                scaleFactor = this.value;
                //updating text, multiplying by a little more than 1 so that toFixed will work properly
                document.getElementById("zoomOutput").innerHTML = (scaleFactor * 1.000001).toFixed(1);
            }

            function updateResolution(bb) {
                //same as in scale factor function
                pixelSize = this.value;
                document.getElementById("resolutionOutput").innerHTML = pixelSize;

                //redraw after a set amount of time
                setTimeout(draw, 200);
            }
        </script>
    </head>
    <body>
        <div id="centerModule">
        <canvas id="cavo" width="640" height="480"></canvas><br>
        <p>Click to zoom in, and adjust sliders to control draw factors</p>
        <input type="range" min="1" max="5" value="1" class="slider" id="resolutionRange"><br>
        <p>Current pixel size: <span id="resolutionOutput">1</span></p>
        <input type="range" min="0.5" max="3" value="1.5" step="0.1" class="slider" id="zoomRange"><br>
        <p>Current zoom scale multiplier: <span id="zoomOutput">1.5</span></p>
        <p>Current position in (x, y, zoom): <span id="totalPos">1</span></p>
        </div>
    </body>
</html>