<html>
    <head>
        <style>
            body {
                background-color: slateblue;
            }

            #canv {
                margin: auto;
                text-align: center;
                display: block;
            }

            #explanText {
                margin: auto;
                text-align: center;
            }


        </style>
        <script>
            window.onload = setup;

            var canvas;
			var ctx;
			//final array
			var dataLayout = [];
			
			//helper arrays
			var pRandArray = [];
			var vectorTable = [];
			
			var vTableSize = 16;
			var pRASize = vTableSize * vTableSize;

            var noiseWidth;
            var noiseHeight;
            var nScale = 25;

            var pixelSize = 3;
            var time = 0;
            var frameTime = 30;

            let redraw;

            function setup() {
                canvas = document.getElementById("canv");
                ctx = canvas.getContext("2d");

                noiseWidth = Math.ceil(canvas.width / pixelSize);
				noiseHeight = Math.ceil(canvas.height / pixelSize);
				
                generatePRandArray(0.751);
                generateArray();
                generate();
                render();
                redraw = setInterval(iterate, frameTime);
            }

            function render() {
				ctx.globalAlpha = 1;
				ctx.fillStyle = "hsl(" + time + ", 100%, 50%)";
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				
                //two for loops for two dimensions
                for (var y=0;y<noiseHeight;y++) {
                    for (var x=0;x<noiseWidth;x++) {
                        //color based off of value in dataLayout
						var alpha = generateValue(x, y);
						ctx.fillStyle = "#FFFFFF";
						ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                    }
                }
            }

            function iterate() {
                //iterate gives the appearance of movement by removing the first row and adding another row to the end.
                //deleting first row
                dataLayout.splice(0, 1);
                dataLayout.push([]);
                
                render();

                //time is so that the base color changes
                time += 0.0625;
            }
            
            function generatePRandArray(seedBetween0And1) {
                //generates a pseudo-random array for the vector table
                pRandArray = [];
                var x = seedBetween0And1;
                for (var u=0;u<pRASize;u++) {
                    //uses a logistic function with a high r value to get a pseudo-random result
                    x = x * 3.947 * (1-x);
                    //floor and multiply by 255 to get number between 0 and 255
                    pRandArray.push(Math.floor(x * 255));
                }
			}
			
			function generateVectorTable() {


			}
			
			function generateArray() {
                //create all rows
				for (var row=0;row<noiseHeight;row++) {
					//create row
					dataLayout.push([]);
					//append row with 0s
					for (var column=0;column<noiseWidth;column++) {
						dataLayout[row].push(0);
					}
				}
			}

            function generateValue(x, y) {
                //account for scaling
                x /= nScale;
                y /= nScale;
				//accounting for pixel size
				x *= (pixelSize / 4);
                y *= (pixelSize / 4);

                //now that we have the requested x and y, we can generate perlin noise from it
                //getting the square that the (x, y) coordinate is in
                //modulate by 255 so that it doesn't leave the array
                var xSquare = Math.floor(x) % 255;
                var ySquare = Math.floor(y) % 255;
                //find the coordinate position in square (for distance vectors)
                var xPart = x % 1;
				var yPart = y % 1;
				//get square points (for grid vectors)

				//take dot product of all 4 vectors
				

                
                //return value
                var v = value;
                //fade function for smooth interpolation (is 6v^5 - 15v^4 + 10v^3)
                return (6 * (v * v * v * v * v)) - (15 * (v * v * v * v) + (10 * (v * v * v)));
			}
			
			//helper functions
			function dotProduct(dir1, dir2, mag1, mag2) {
				var totalAngle = (dir1 + dir2) % (Math.PI * 2);
				var multLengths = mag1 * mag2;
				var dotProduct = Math.cos(totalAngle) * multLengths;

				return dotProduct;

			}

			function numToVector(inputNum) {
				var angle = inputNum % 16;
				var magni = (inputNum - angle) / 16;

				angle = (angle / 16) * (Math.PI * 2);
				magni = magni / 15;

				//after getting angle and magnitude, vectors are converted into [xy] pair for easier access
				var xComp = 
				var yComp = 
 				return [xComp, yComp];
			}


        </script>
    </head>
    <body>
        <canvas id="canv" width="640" height="480"></canvas><br>
        <p id="explanText">
            How it works: <br>
            <strong>generation:</strong><br>
			noise noises
			<strong>drawing:</strong><br>
			
        </p>
    </body>
</html>