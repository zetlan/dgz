<!doctype html>
<!-- Copyright Davis Zetlan
Nov-17-2019 -->
<html>
	<head>
    	<title>The Ascent v1.31</title>

    	<style>
      		#canvas {
        		border-style: double;
        		border-color: slateblue;
        		margin: auto;
        		display: block;
      		}
    	</style>
    	<script type="text/javascript">
      		window.addEventListener("keydown", keyPress, false);
      		window.addEventListener("keyup", keyNegate, false);
      		//setting up variables for later
      		var canvas;
      		var ctx;
			var dx = 0;
			var dy = 0;
			
			var hasPressed = 0;
			
			var arrayValue;
			var centerX;
			var centerY;
			var squareSize = 40;
			var mouseX;
			var mouseY;
			var clicked = 0;
			var numToSet = 0;
			var canvasArea;
			var gravity = squareSize / 100;
			
			var timer;
			var dayLength = 12500;
			var time = 0;
			var points = 0;
			
			var gameState = -1;
			var yes = 0;
			var delay = 10;
			
			//all the colors used
			var landColor = "#008800";
			var lLandColor = "#77B964";
			var stoneColor = "#494D5E";
			var lStoneColor = "#797D8E";
			var woodColor = "#AB6E05";
			var lWoodColor = "#DB8F0B";
			var skyColor = "#AAAAFF";
			var floorColor = "#D1AC6D";
			var farmColor = "#916B2F";
			var endingColor = "#FF00FF";
			var startingColor = "#00FF00";
			var blackColor = "#000000";
			
			var menuColor = "#333366";
			var textColor = "#EEEEEE";
			var ballColor = "#FF00FF";
			var entityColor = "#8800FF";
			var nightFilter = "#000044";
			
			var prep = [0, 0, 0, 0];

			var menuText = ["The Ascent", "Start", "(Click to start)"];
			
			var loadingMap;

			//the map array. It is rather large.

			var map = [[4, 3, 4, 3, 4, 4, 4],
						[3, 3, 3, 3, 3, 3, 4],
						[3, 3, 4, 4, 4, 4, 4],
						[4, 4, 4, 4, 4, 4, 4],
						[4, 4, 4, 4, 4, 3, 4],
						[4, 4, 4, 4, 4, 4, 4],
						[4, 4, 4, 4, 4, 4, 4],
						[4, 4, 4, 4, 4, 3, 4],
						[4, 4, 4, 4, 4, 3, 4],
						[3, 3, 3, 3, 3, 3, 3],
						[4, 4, 4, 4, 4, 4, 4]];
			
			
			/*this array determines the positions of all the entities as well as their profession.
			It's format is [x, y, point value, color, exists or not]*/
			var entityData = [[54.5 * squareSize, 105 * squareSize, 10, "#8A8A2F", 1],
								[6.5 * squareSize, 12.5 * squareSize, 100, "#FFEA4F", 1],
								[24.5 * squareSize, 92.5 * squareSize, "To move, use the arrow keys or WASD.", "#000000", 2],
								[27.5 * squareSize, 82.5 * squareSize, "You regain your jump when hitting the lower side of blocks.", "#000000", 2],
								[55.5 * squareSize, 7.5 * squareSize, "Hey â˜ƒ", "#000000", 2]
								];
			var entitySpeed = 1;

			//this array says all the surfaces that are solid and cannot be walked through.
			var solidSurfaces = [1, 3, 5];
			
			//objects go here
			class Main {
				constructor(x, y) {
					this.x = x;
					this.y = y;
					this.dx = 0;
					this.dy = 0;
					this.onGround = true;
				}

				handlePosition() {
					var arrayValue;
					//applying x and getting array value
					this.x += this.dx;

					//dealing with screen wrapping
					var readXSquare = Math.floor(this.x / squareSize);
					if (readXSquare >= loadingMap[0].length) {
						readXSquare -= loadingMap[0].length;
					} else if (readXSquare < 0) {
						readXSquare += loadingMap[0].length;
					}
					//reading from map
					try {
						arrayValue = loadingMap[Math.floor(this.y / squareSize)][readXSquare];
					}
					catch (error) {
						arrayValue = 9;
					}
					
					
					//check if array value is solid
        			for (var l=0; l<solidSurfaces.length; l++) {
        				if (arrayValue == solidSurfaces[l]) {
							//if it is, get rid of velocity and reverse change, end loop
							this.x -= this.dx;
							this.dx = 0;
							l = solidSurfaces.length + 1;
        				}
					}
					
        			//and for y
					this.y += this.dy;

					readXSquare = Math.floor(this.x / squareSize);
					if (readXSquare >= loadingMap[0].length) {
						readXSquare -= loadingMap[0].length;
					} else if (readXSquare < 0) {
						readXSquare += loadingMap[0].length;
					}
					
        			try {
						arrayValue = loadingMap[Math.floor(this.y / squareSize)][readXSquare];
					}
					catch (error) {
						arrayValue = 9;
					}
        
        			for (var k=0; k<solidSurfaces.length; k++) {
        				if (arrayValue == solidSurfaces[k]) {
							this.y -= this.dy;
							this.dy = 0;
							l = solidSurfaces.length + 1;
							this.onGround = true;
        				}
        			}
				}
			}

			//the camera is mostly a static class, but it stores important things like squares per screen and position to draw from.
			class Camera extends Main {
				constructor(x, y) {
					super(x, y);
					this.xSquaresPerScreen = Math.floor(canvas.width / squareSize) + 2;
					this.ySquaresPerScreen = Math.floor(canvas.height / squareSize) + 2;
				}
			}

			class Player extends Main {
				constructor(x, y) {
					super(x, y);
					this.ax = 0;
					this.ay = 0;
					this.accRate = 0.3;
					this.gravity = 0.5;
					this.slowRate = 0.85;
					this.jumpStrength = 11.5;
					this.onGround = false;
					this.canMove = false;

					this.maxSpeed = 5;
				}

				tick() {
					//updating dx
					this.dx += this.ax;
					if (this.ax == 0) {
						this.dx *= this.slowRate;
					}
					//gravity
					this.dy += this.gravity;

					//making sure that dx/dy are not too far out of range

					//dx
					if (Math.abs(this.dx) > this.maxSpeed) {
						if (this.dx > 0) {
							this.dx = this.maxSpeed;
						} else {
							this.dx = this.maxSpeed * -1;
						}
					}

					//dy is positively bounded so that the player never falls through blocks
					if (this.dy > squareSize - 1) {
						this.dy = squareSize - 1;
					}

					//updating x and y with position handling
					super.handlePosition();
				}

				beDrawn() {
					ctx.fillStyle = ballColor;
					ctx.beginPath();
					ctx.ellipse(this.x - camera.x, this.y - camera.y, squareSize / 4, squareSize / 4, Math.PI, 0, Math.PI * 4);
					ctx.fill();
				}
			}
			window.onload = setup;
			document.onmousemove = mouseHandle;
			document.onmousedown = clickHandle;

			let camera;
			let character;
			// the initializing function.
			function setup() {
				
				canvas = document.getElementById("canvas");
				ctx = canvas.getContext("2d");
				loadingMap = map;
				setInterval(draw, 15);
				
				centerX = canvas.width / 2;
				centerY = canvas.height / 2;

				camera = new Camera(0, 0);
				character = new Player(100, 100);
			}
			
			function keyPress(h) {
				//37, 38, 39, and 40 are the arrow keys. Left, up, and right can only be activated if delay is 0, meaning not during cutscenes. Down can still be used.
				//there is one switch statement that controls all the key presses
				//dx is controlled by ax, but dy is updated directly for a more snappy feeling
				switch (h.keyCode) {
					case 65:
					case 37:
						character.ax = character.accRate * -1;
						break;
					case 87:
					case 38:
						if (character.onGround) {
							character.dy = character.jumpStrength * -1;
							character.onGround = false;
						}
						break;
					case 68:
					case 39:
						character.ax = character.accRate * 1;
						break;
					case 83:
					case 40:
						character.dy += character.jumpStrength;
						break;
					case 90:
						hasPressed = 1;
						break;
				}
			}
			
			function keyNegate(h) {
				switch (h.keyCode) {
					case 65:
					case 37:
						character.ax = 0;
						break;
					case 87:
					case 38:
						character.ay = 0;
						break;
					case 68:
					case 39:
						character.ax = 0;
						break;
					case 83:
					case 40:
						character.ay = 0;
						break;
				}
			}
			
			function mouseHandle(h) {
				canvasArea = canvas.getBoundingClientRect();
				mouseX = Math.round(h.clientX - canvasArea.left);
				mouseY = Math.round(h.clientY - canvasArea.top);
			}
			
			function clickHandle() {
				if (prep[0] >= 5 || gameState < 0) {
					clicked = 1;
				}
			}
			
			function drawCircles() {
				//this for loop handles the entities one by one.
				for (a=0; a < entityData.length; a++) {
					//draws the entities, if they currently exist.
				//if their existance is set to 2, it means that they are text and are handled differently.
				if (entityData[a][4] > 0) {
					var entityScreenX = entityData[a][0] - cornerCoords[0];
					var entityScreenY = entityData[a][1] - cornerCoords[1];
					ctx.fillStyle = entityData[a][3];
					if (entityData[a][4] == 2) {
					ctx.font = "15px Century Gothic";
					ctx.textAlign = "center";
					ctx.fillText(entityData[a][2], entityScreenX, entityScreenY);
					} else {
						ctx.beginPath();
						ctx.ellipse(entityScreenX, entityScreenY, squareSize / 4, squareSize / 4, Math.PI, 0, Math.PI * 4);
						ctx.fill();

					var xDist = Math.abs(entityData[a][0] - x);
					var yDist = Math.abs(entityData[a][1] - y);

					//if the player is close to the good orb, then they win.
					if (xDist < 50 && yDist < 50 && a == 1) {
						points = points + 2;
					}
					}
				}
				}
			}

			/* mapSquare is the function that draws all the different tiles. */
			function mapSquare(value, ex, why, offset) {
					switch (value) {
					case 0:
						ctx.fillStyle = landColor;
						ctx.fillRect(ex, why, squareSize - offset, squareSize - offset);
						break;
					case 1:
						ctx.fillStyle = landColor;
						ctx.fillRect(ex, why, squareSize - offset, squareSize - offset);
						ctx.fillStyle = lLandColor;
						ctx.fillRect(ex + (squareSize / 8), why + (squareSize / 8), (squareSize * 0.75) - offset, (squareSize * 0.75) - offset);
						break;
					case 2:
						ctx.fillStyle = stoneColor;
						ctx.fillRect(ex, why, squareSize - offset, squareSize - offset);
						break;
					case 3:
						ctx.fillStyle = stoneColor;
						ctx.fillRect(ex, why, squareSize - offset, squareSize - offset);
						ctx.fillStyle = lStoneColor;
						ctx.fillRect(ex + (squareSize / 8), why + (squareSize / 8), (squareSize * 0.75) - offset, (squareSize * 0.75) - offset);
						break;
					case 4:
					ctx.fillStyle = woodColor;
						ctx.fillRect(ex, why, squareSize - offset, squareSize - offset);
					break;
					case 5:
						ctx.fillStyle = woodColor;
						ctx.fillRect(ex, why, squareSize - offset, squareSize - offset);
						ctx.fillStyle = lWoodColor;
						ctx.fillRect(ex + (squareSize / 8), why + (squareSize / 8), (squareSize * 0.75) - offset, (squareSize * 0.75) - offset);
					break;
					case 9:
					default:
						ctx.fillStyle = skyColor;
						ctx.fillRect(ex, why, squareSize - offset, squareSize - offset);
						break;
				}
				}
					
			// drawing the map
			function drawMap() {

				//uses two for loops, one for x and one for y
				for (var p=0; p<camera.ySquaresPerScreen; p++) {
					for (var o=0;o<camera.xSquaresPerScreen;o++) {
						//figuring out where to read from
						var value;
						var xSquare = Math.floor((camera.x + (o * squareSize)) / squareSize);
						var ySquare = Math.floor((camera.y + (p * squareSize)) / squareSize);

						//wrapping horizontally
						if (xSquare >= loadingMap[ySquare].length) {
							xSquare -= loadingMap[ySquare].length;
						} else if (xSquare < 0) {
							xSquare += loadingMap[ySquare].length;
						}

						//where to write to
						// [-1 * square offset] + [square numbers]
						var xPos = (-1 * (camera.x % squareSize)) + (o * squareSize);
						var yPos = (-1 * (camera.y % squareSize)) + (p * squareSize);
						try {
							value = loadingMap[ySquare][xSquare];
						}
						catch (error) {
							value = 9;
						}
						//the actual drawing
						mapSquare(value, xPos, yPos, 0);
					}
				}
			}
			
			function drawMenu() {
				//filters count as part of the menu
				ctx.textAlign = "left";
				//prep filter, it's probably not the best to handle the prepping logic inside of a draw function but whatever
				if (prep[0] > 0 && prep[0] < 5) {
					ctx.globalAlpha = 0.2;
					ctx.fillStyle = endingColor;
					ctx.fillRect(0, 0, canvas.width * (prep[0] / 4.5), canvas.height);
					ctx.globalAlpha = 1.0;
					prep[1] = prep[1] - 1;
					if (prep[1] < 1) {
						prep[0] = prep[0] - 0.05;
					}
				}
				//prep for return filter
				if (prep[2] > 0 && prep[2] < 5) {
					ctx.globalAlpha = 0.2;
					ctx.fillStyle = startingColor;
					ctx.fillRect(0, 0, canvas.width * (prep[2] / 4.5), canvas.height);
					ctx.globalAlpha = 1.0;
					prep[3] = prep[3] - 1;
					if (prep[3] < 1) {
						prep[2] = prep[2] - 0.05;
					}
				}
				
					
				//draws main menu things
				ctx.fillStyle = menuColor;
				ctx.fillRect(0, canvas.height * 0.8, canvas.width, canvas.height * 0.2)
				ctx.fillStyle = textColor;
				ctx.font = "20px Century Gothic";
				ctx.fillText("Time elapsed: " + (time / 66.6666666).toFixed(2), 15, canvas.height * 0.95); 
				ctx.fillText("Points: " + points, 15, canvas.height * 0.87);
			}

			function draw() {
				drawMap();
				character.beDrawn();
				character.tick();
			}
			
			function mapEdit() {
				//converts the mouses position into a spot on the map, allows for click edits.
				var max = 9;
				var arrayPosX = mouseX + cornerCoords[0];
				var arrayPosY = mouseY + cornerCoords[1];
				time = Math.round(dayLength * 0.80);
				
				if (clicked == 1) {
					clicked = 0;
				loadingMap[Math.floor(arrayPosY / squareSize)][Math.floor(arrayPosX / squareSize)] = numToSet;
				if (loadingMap[Math.floor(arrayPosY / squareSize)][Math.floor(arrayPosX / squareSize)] > max) {
					loadingMap[Math.floor(arrayPosY / squareSize)][Math.floor(arrayPosX / squareSize)] = 0;
				}
				}

				//makes sure that text displays the coordinates
				textValue[0] = 9;
				textTime = 100;
			}
			
			function mapOutput() {
				var hey = "";
				for (s=0;s<loadingMap.length;s++) {
					hey = hey + "\n [";
					for (t=0;t<loadingMap[s].length;t++) {
					//special case for the end of a line, in addition to a regular case
					if (t == (loadingMap[s].length - 1)) {
					hey = hey + loadingMap[s][t];
					} else {
					hey = hey + loadingMap[s][t] + ", ";
					}
				}
				//the same thing happens here with the end of the map
				if (s == (map.length - 1)) {
					hey = hey + "]";
				} else {
					hey = hey + "],";
				}
				}
				console.log(hey);
			}
    	</script>
  	</head>
  	<body>
    	<div>
      		<canvas id="canvas" width="512" height="384">
      		</canvas>
    	</div>
	</body>
</html>